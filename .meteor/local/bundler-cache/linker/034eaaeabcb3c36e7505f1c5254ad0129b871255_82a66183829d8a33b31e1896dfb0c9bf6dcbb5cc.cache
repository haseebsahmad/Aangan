[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar FS = Package['cfs:base-package'].FS;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar PowerQueue = Package['cfs:power-queue'].PowerQueue;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                      //\n// packages/cfs_worker/fileWorker.js                                                                    //\n//                                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                        //\n//// TODO: Use power queue to handle throttling etc.\n//// Use observe to monitor changes and have it create tasks for the power queue\n//// to perform.\n\n/**\n * @public\n * @type Object\n */\nFS.FileWorker = {};\n\n/**\n * @method FS.FileWorker.observe\n * @public\n * @param {FS.Collection} fsCollection\n * @returns {undefined}\n *\n * Sets up observes on the fsCollection to store file copies and delete\n * temp files at the appropriate times.\n */\nFS.FileWorker.observe = function(fsCollection) {\n\n  // Initiate observe for finding newly uploaded/added files that need to be stored\n  // per store.\n  FS.Utility.each(fsCollection.options.stores, function(store) {\n    var storeName = store.name;\n    fsCollection.files.find(getReadyQuery(storeName), {\n      fields: {\n        copies: 0\n      }\n    }).observe({\n      added: function(fsFile) {\n        // added will catch fresh files\n        FS.debug && console.log(\"FileWorker ADDED - calling saveCopy\", storeName, \"for\", fsFile._id);\n        saveCopy(fsFile, storeName);\n      },\n      changed: function(fsFile) {\n        // changed will catch failures and retry them\n        FS.debug && console.log(\"FileWorker CHANGED - calling saveCopy\", storeName, \"for\", fsFile._id);\n        saveCopy(fsFile, storeName);\n      }\n    });\n  });\n\n  // Initiate observe for finding files that have been stored so we can delete\n  // any temp files\n  fsCollection.files.find(getDoneQuery(fsCollection.options.stores)).observe({\n    added: function(fsFile) {\n      FS.debug && console.log(\"FileWorker ADDED - calling deleteChunks for\", fsFile._id);\n      try {\n        FS.TempStore.removeFile(fsFile);\n      } catch(err) {\n        console.error(err);\n      }\n    }\n  });\n\n  // Initiate observe for catching files that have been removed and\n  // removing the data from all stores as well\n  fsCollection.files.find().observe({\n    removed: function(fsFile) {\n      FS.debug && console.log('FileWorker REMOVED - removing all stored data for', fsFile._id);\n      //remove from temp store\n      FS.TempStore.removeFile(fsFile);\n      //delete from all stores\n      FS.Utility.each(fsCollection.options.stores, function(storage) {\n        storage.adapter.remove(fsFile);\n      });\n    }\n  });\n};\n\n/**\n *  @method getReadyQuery\n *  @private\n *  @param {string} storeName - The name of the store to observe\n *\n *  Returns a selector that will be used to identify files that\n *  have been uploaded but have not yet been stored to the\n *  specified store.\n *\n *  {\n *    uploadedAt: {$exists: true},\n *    'copies.storeName`: null,\n *    'failures.copies.storeName.doneTrying': {$ne: true}\n *  }\n */\nfunction getReadyQuery(storeName) {\n  var selector = {uploadedAt: {$exists: true}};\n  selector['copies.' + storeName] = null;\n  selector['failures.copies.' + storeName + '.doneTrying'] = {$ne: true};\n  return selector;\n}\n\n/**\n *  @method getDoneQuery\n *  @private\n *  @param {Array} stores - The stores array from the FS.Collection options\n *\n *  Returns a selector that will be used to identify files where all\n *  stores have successfully save or have failed the\n *  max number of times but still have chunks. The resulting selector\n *  should be something like this:\n *\n *  {\n *    $and: [\n *      {chunks: {$exists: true}},\n *      {\n *        $or: [\n *          {\n *            $and: [\n *              {\n *                'copies.storeName': {$ne: null}\n *              },\n *              {\n *                'copies.storeName': {$ne: false}\n *              }\n *            ]\n *          },\n *          {\n *            'failures.copies.storeName.doneTrying': true\n *          }\n *        ]\n *      },\n *      REPEATED FOR EACH STORE\n *    ]\n *  }\n *\n */\nfunction getDoneQuery(stores) {\n  var selector = {\n    $and: [{chunks: {$exists: true}}]\n  };\n\n  // Add conditions for all defined stores\n  FS.Utility.each(stores, function(store) {\n    var storeName = store.name;\n    var copyCond = {$or: [{$and: []}]};\n    var tempCond = {};\n    tempCond[\"copies.\" + storeName] = {$ne: null};\n    copyCond.$or[0].$and.push(tempCond);\n    tempCond = {};\n    tempCond[\"copies.\" + storeName] = {$ne: false};\n    copyCond.$or[0].$and.push(tempCond);\n    tempCond = {};\n    tempCond['failures.copies.' + storeName + '.doneTrying'] = true;\n    copyCond.$or.push(tempCond);\n    selector.$and.push(copyCond);\n  })\n\n  return selector;\n}\n\n/**\n * @method saveCopy\n * @private\n * @param {FS.File} fsFile\n * @param {string} storeName\n * @param {Object} options\n * @param {Boolean} [options.overwrite=false] - Force save to the specified store?\n * @returns {undefined}\n *\n * Saves to the specified store. If the\n * `overwrite` option is `true`, will save to the store even if we already\n * have, potentially overwriting any previously saved data. Synchronous.\n */\nfunction saveCopy(fsFile, storeName, options) {\n  options = options || {};\n\n  var storage = FS.StorageAdapter(storeName);\n  if (!storage) {\n    throw new Error('No store named \"' + storeName + '\" exists');\n  }\n\n  FS.debug && console.log('saving to store ' + storeName);\n\n  try {\n    var writeStream = storage.adapter.createWriteStream(fsFile);\n    var readStream = FS.TempStore.createReadStream(fsFile);\n\n    // Pipe the temp data into the storage adapter\n    readStream.pipe(writeStream);\n  } catch(err) {\n    console.error(err);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"cfs:worker\");\n\n})();\n","servePath":"/packages/cfs_worker.js"}]