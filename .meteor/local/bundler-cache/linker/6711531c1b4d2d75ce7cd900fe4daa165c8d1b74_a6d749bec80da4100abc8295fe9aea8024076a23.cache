[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar URL = Package.url.URL;\nvar URLSearchParams = Package.url.URLSearchParams;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar fetch = Package.fetch.fetch;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar HTTP, HTTPInternals;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"http\":{\"httpcall_server.js\":function module(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/http/httpcall_server.js                                                                                 //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nmodule.export({\n  HTTP: () => HTTP,\n  HTTPInternals: () => HTTPInternals\n});\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet fetch, Request;\nmodule.link(\"meteor/fetch\", {\n  fetch(v) {\n    fetch = v;\n  },\n\n  Request(v) {\n    Request = v;\n  }\n\n}, 1);\nlet URL, URLSearchParams;\nmodule.link(\"meteor/url\", {\n  URL(v) {\n    URL = v;\n  },\n\n  URLSearchParams(v) {\n    URLSearchParams = v;\n  }\n\n}, 2);\nlet HTTP, makeErrorByStatus, populateData;\nmodule.link(\"./httpcall_common.js\", {\n  HTTP(v) {\n    HTTP = v;\n  },\n\n  makeErrorByStatus(v) {\n    makeErrorByStatus = v;\n  },\n\n  populateData(v) {\n    populateData = v;\n  }\n\n}, 3);\nconst hasOwn = Object.prototype.hasOwnProperty;\n/**\n * @deprecated\n */\n\nconst HTTPInternals = {};\n\n// _call always runs asynchronously; HTTP.call, defined below,\n// wraps _call and runs synchronously when no callback is provided.\nfunction _call(method, url, options, callback) {\n  ////////// Process arguments //////////\n  if (!callback && typeof options === 'function') {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (hasOwn.call(options, 'beforeSend')) {\n    throw new Error('Option beforeSend not supported on server.');\n  }\n\n  method = (method || '').toUpperCase();\n\n  if (!/^https?:\\/\\//.test(url)) {\n    throw new Error('url must be absolute and start with http:// or https://');\n  }\n\n  const headers = {};\n  let content = options.content;\n\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n  let paramsForUrl;\n  let paramsForBody;\n\n  if (content || method === 'GET' || method === 'HEAD') {\n    paramsForUrl = options.params;\n  } else {\n    paramsForBody = options.params;\n  }\n\n  const newUrl = URL._constructUrl(url, options.query, paramsForUrl);\n\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0) {\n      throw new Error('auth option should be of the form \"username:password\"');\n    }\n\n    const base64 = Buffer.from(options.auth, 'ascii').toString('base64');\n    headers['Authorization'] = \"Basic \".concat(base64);\n  }\n\n  if (paramsForBody) {\n    const data = new URLSearchParams();\n    Object.entries(paramsForBody).forEach(_ref => {\n      let [key, value] = _ref;\n      data.append(key, value);\n    });\n    content = data;\n    headers['Content-Type'] = 'application/x-www-form-urlencoded';\n  }\n\n  if (options.headers) {\n    Object.keys(options.headers).forEach(function (key) {\n      headers[key] = options.headers[key];\n    });\n  }\n\n  let caching;\n\n  if (options.caching) {// TODO implement fetch-specific options\n  }\n\n  let corsMode;\n\n  if (options.mode) {// TODO implement fetch-specific options\n  }\n\n  let credentials; // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n\n  callback = function (cb) {\n    let called = false;\n    return function (error, response) {\n      if (!called) {\n        called = true;\n\n        if (error && response) {\n          error.response = response;\n        }\n\n        cb(error, response);\n      }\n    };\n  }(callback); // is false if false, otherwise always true\n\n\n  const followRedirects = options.followRedirects === false ? 'manual' : 'follow'; ////////// Kickoff! //////////\n  // Allow users to override any request option with the npmRequestOptions\n  // option.\n\n  const requestOptions = {\n    method: method,\n    caching: caching,\n    mode: corsMode,\n    jar: false,\n    timeout: options.timeout,\n    body: content,\n    redirect: followRedirects,\n    referrer: options.referrer,\n    integrity: options.integrity,\n    headers: headers\n  };\n  const request = new Request(newUrl, requestOptions);\n  fetch(request).then(res => Promise.asyncApply(() => {\n    const content = Promise.await(res.text());\n    const response = {};\n    response.statusCode = res.status;\n    response.content = '' + content; // fetch headers don't allow simple read using bracket notation\n    // so we iterate their entries and assign them to a new Object\n\n    response.headers = {};\n\n    for (const entry of res.headers.entries()) {\n      const [key, val] = entry;\n      response.headers[key] = val;\n    }\n\n    response.ok = res.ok;\n    response.redirected = res.redirected;\n    populateData(response);\n\n    if (response.statusCode >= 400) {\n      const error = makeErrorByStatus(response.statusCode, response.content);\n      callback(error, response);\n    } else {\n      callback(undefined, response);\n    }\n  })).catch(err => callback(err));\n}\n\nHTTP.call = Meteor.wrapAsync(_call);\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"httpcall_common.js\":function module(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/http/httpcall_common.js                                                                                 //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar MAX_LENGTH = 500; // if you change this, also change the appropriate test\n\nvar slice = Array.prototype.slice;\n\nexports.makeErrorByStatus = function (statusCode, content) {\n  var message = \"failed [\" + statusCode + \"]\";\n\n  if (content) {\n    var stringContent = typeof content == \"string\" ? content : content.toString();\n    message += ' ' + truncate(stringContent.replace(/\\n/g, ' '), MAX_LENGTH);\n  }\n\n  return new Error(message);\n};\n\nfunction truncate(str, length) {\n  return str.length > length ? str.slice(0, length) + '...' : str;\n} // Fill in `response.data` if the content-type is JSON.\n\n\nexports.populateData = function (response) {\n  // Read Content-Type header, up to a ';' if there is one.\n  // A typical header might be \"application/json; charset=utf-8\"\n  // or just \"application/json\".\n  var contentType = (response.headers['content-type'] || ';').split(';')[0]; // Only try to parse data as JSON if server sets correct content type.\n\n  if (['application/json', 'text/javascript', 'application/javascript', 'application/x-javascript'].indexOf(contentType) >= 0) {\n    try {\n      response.data = JSON.parse(response.content);\n    } catch (err) {\n      response.data = null;\n    }\n  } else {\n    response.data = null;\n  }\n};\n\nvar HTTP = exports.HTTP = {};\n/**\n * @summary Send an HTTP `GET` request. Equivalent to calling [`HTTP.call`](#http_call) with \"GET\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\n\nHTTP.get = function ()\n/* varargs */\n{\n  return HTTP.call.apply(this, [\"GET\"].concat(slice.call(arguments)));\n};\n/**\n * @summary Send an HTTP `POST` request. Equivalent to calling [`HTTP.call`](#http_call) with \"POST\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\n\n\nHTTP.post = function ()\n/* varargs */\n{\n  return HTTP.call.apply(this, [\"POST\"].concat(slice.call(arguments)));\n};\n/**\n * @summary Send an HTTP `PUT` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PUT\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\n\n\nHTTP.put = function ()\n/* varargs */\n{\n  return HTTP.call.apply(this, [\"PUT\"].concat(slice.call(arguments)));\n};\n/**\n * @summary Send an HTTP `DELETE` request. Equivalent to calling [`HTTP.call`](#http_call) with \"DELETE\" as the first argument. (Named `del` to avoid conflict with the Javascript keyword `delete`)\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\n\n\nHTTP.del = function ()\n/* varargs */\n{\n  return HTTP.call.apply(this, [\"DELETE\"].concat(slice.call(arguments)));\n};\n/**\n * @summary Send an HTTP `PATCH` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PATCH\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\n\n\nHTTP.patch = function ()\n/* varargs */\n{\n  return HTTP.call.apply(this, [\"PATCH\"].concat(slice.call(arguments)));\n};\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/http/httpcall_server.js\");\n\n/* Exports */\nPackage._define(\"http\", exports, {\n  HTTP: HTTP,\n  HTTPInternals: HTTPInternals\n});\n\n})();\n","servePath":"/packages/http.js","sourceMap":{"version":3,"sources":["packages/http/httpcall_server.js","packages/http/httpcall_common.js"],"names":["module","export","HTTP","HTTPInternals","Meteor","link","v","fetch","Request","URL","URLSearchParams","makeErrorByStatus","populateData","hasOwn","Object","prototype","hasOwnProperty","_call","method","url","options","callback","call","Error","toUpperCase","test","headers","content","data","JSON","stringify","paramsForUrl","paramsForBody","params","newUrl","_constructUrl","query","auth","indexOf","base64","Buffer","from","toString","entries","forEach","key","value","append","keys","caching","corsMode","mode","credentials","cb","called","error","response","followRedirects","requestOptions","jar","timeout","body","redirect","referrer","integrity","request","then","res","text","statusCode","status","entry","val","ok","redirected","undefined","catch","err","wrapAsync","MAX_LENGTH","slice","Array","exports","message","stringContent","truncate","replace","str","length","contentType","split","parse","get","apply","concat","arguments","post","put","del","patch"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAAA,MAAM,CAACC,MAAP,CAAc;AAACC,MAAI,EAAC,MAAIA,IAAV;AAAeC,eAAa,EAAC,MAAIA;AAAjC,CAAd;AAA+D,IAAIC,MAAJ;AAAWJ,MAAM,CAACK,IAAP,CAAY,eAAZ,EAA4B;AAACD,QAAM,CAACE,CAAD,EAAG;AAACF,UAAM,GAACE,CAAP;AAAS;;AAApB,CAA5B,EAAkD,CAAlD;AAAqD,IAAIC,KAAJ,EAAUC,OAAV;AAAkBR,MAAM,CAACK,IAAP,CAAY,cAAZ,EAA2B;AAACE,OAAK,CAACD,CAAD,EAAG;AAACC,SAAK,GAACD,CAAN;AAAQ,GAAlB;;AAAmBE,SAAO,CAACF,CAAD,EAAG;AAACE,WAAO,GAACF,CAAR;AAAU;;AAAxC,CAA3B,EAAqE,CAArE;AAAwE,IAAIG,GAAJ,EAAQC,eAAR;AAAwBV,MAAM,CAACK,IAAP,CAAY,YAAZ,EAAyB;AAACI,KAAG,CAACH,CAAD,EAAG;AAACG,OAAG,GAACH,CAAJ;AAAM,GAAd;;AAAeI,iBAAe,CAACJ,CAAD,EAAG;AAACI,mBAAe,GAACJ,CAAhB;AAAkB;;AAApD,CAAzB,EAA+E,CAA/E;AAAkF,IAAIJ,IAAJ,EAASS,iBAAT,EAA2BC,YAA3B;AAAwCZ,MAAM,CAACK,IAAP,CAAY,sBAAZ,EAAmC;AAACH,MAAI,CAACI,CAAD,EAAG;AAACJ,QAAI,GAACI,CAAL;AAAO,GAAhB;;AAAiBK,mBAAiB,CAACL,CAAD,EAAG;AAACK,qBAAiB,GAACL,CAAlB;AAAoB,GAA1D;;AAA2DM,cAAY,CAACN,CAAD,EAAG;AAACM,gBAAY,GAACN,CAAb;AAAe;;AAA1F,CAAnC,EAA+H,CAA/H;AAM3W,MAAMO,MAAM,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAAhC;AAEA;AACA;AACA;;AACO,MAAMb,aAAa,GAAG,EAAtB;;AAEP;AACA;AACA,SAASc,KAAT,CAAgBC,MAAhB,EAAwBC,GAAxB,EAA6BC,OAA7B,EAAsCC,QAAtC,EAAgD;AAC9C;AAEA,MAAI,CAACA,QAAD,IAAa,OAAOD,OAAP,KAAmB,UAApC,EAAgD;AAC9C;AACAC,YAAQ,GAAGD,OAAX;AACAA,WAAO,GAAG,IAAV;AACD;;AAEDA,SAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,MAAIP,MAAM,CAACS,IAAP,CAAYF,OAAZ,EAAqB,YAArB,CAAJ,EAAwC;AACtC,UAAM,IAAIG,KAAJ,CAAU,4CAAV,CAAN;AACD;;AAEDL,QAAM,GAAG,CAACA,MAAM,IAAI,EAAX,EAAeM,WAAf,EAAT;;AAEA,MAAI,CAAC,eAAeC,IAAf,CAAoBN,GAApB,CAAL,EAA+B;AAC7B,UAAM,IAAII,KAAJ,CAAU,yDAAV,CAAN;AACD;;AAED,QAAMG,OAAO,GAAG,EAAhB;AACA,MAAIC,OAAO,GAAGP,OAAO,CAACO,OAAtB;;AAEA,MAAIP,OAAO,CAACQ,IAAZ,EAAkB;AAChBD,WAAO,GAAGE,IAAI,CAACC,SAAL,CAAeV,OAAO,CAACQ,IAAvB,CAAV;AACAF,WAAO,CAAC,cAAD,CAAP,GAA0B,kBAA1B;AACD;;AAED,MAAIK,YAAJ;AACA,MAAIC,aAAJ;;AAEA,MAAIL,OAAO,IAAIT,MAAM,KAAK,KAAtB,IAA+BA,MAAM,KAAK,MAA9C,EAAsD;AACpDa,gBAAY,GAAGX,OAAO,CAACa,MAAvB;AACD,GAFD,MAGK;AACHD,iBAAa,GAAGZ,OAAO,CAACa,MAAxB;AACD;;AAED,QAAMC,MAAM,GAAGzB,GAAG,CAAC0B,aAAJ,CAAkBhB,GAAlB,EAAuBC,OAAO,CAACgB,KAA/B,EAAsCL,YAAtC,CAAf;;AAEA,MAAIX,OAAO,CAACiB,IAAZ,EAAkB;AAChB,QAAIjB,OAAO,CAACiB,IAAR,CAAaC,OAAb,CAAqB,GAArB,IAA4B,CAAhC,EAAmC;AACjC,YAAM,IAAIf,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,UAAMgB,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYrB,OAAO,CAACiB,IAApB,EAA0B,OAA1B,EAAmCK,QAAnC,CAA4C,QAA5C,CAAf;AACAhB,WAAO,CAAC,eAAD,CAAP,mBAAoCa,MAApC;AACD;;AAED,MAAIP,aAAJ,EAAmB;AACjB,UAAMJ,IAAI,GAAG,IAAIlB,eAAJ,EAAb;AACAI,UAAM,CAAC6B,OAAP,CAAeX,aAAf,EAA8BY,OAA9B,CAAsC,QAAkB;AAAA,UAAjB,CAACC,GAAD,EAAMC,KAAN,CAAiB;AACtDlB,UAAI,CAACmB,MAAL,CAAYF,GAAZ,EAAiBC,KAAjB;AACD,KAFD;AAGAnB,WAAO,GAAGC,IAAV;AACAF,WAAO,CAAC,cAAD,CAAP,GAA0B,mCAA1B;AACD;;AAED,MAAIN,OAAO,CAACM,OAAZ,EAAqB;AACnBZ,UAAM,CAACkC,IAAP,CAAY5B,OAAO,CAACM,OAApB,EAA6BkB,OAA7B,CAAqC,UAAUC,GAAV,EAAe;AAClDnB,aAAO,CAACmB,GAAD,CAAP,GAAezB,OAAO,CAACM,OAAR,CAAgBmB,GAAhB,CAAf;AACD,KAFD;AAGD;;AAED,MAAII,OAAJ;;AACA,MAAI7B,OAAO,CAAC6B,OAAZ,EAAqB,CACnB;AACD;;AAED,MAAIC,QAAJ;;AACA,MAAI9B,OAAO,CAAC+B,IAAZ,EAAkB,CAChB;AACD;;AAED,MAAIC,WAAJ,CA3E8C,CA6E9C;AACA;;AACA/B,UAAQ,GAAI,UAAUgC,EAAV,EAAc;AACxB,QAAIC,MAAM,GAAG,KAAb;AACA,WAAO,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AAChC,UAAI,CAACF,MAAL,EAAa;AACXA,cAAM,GAAG,IAAT;;AACA,YAAIC,KAAK,IAAIC,QAAb,EAAuB;AACrBD,eAAK,CAACC,QAAN,GAAiBA,QAAjB;AACD;;AACDH,UAAE,CAACE,KAAD,EAAQC,QAAR,CAAF;AACD;AACF,KARD;AASD,GAXU,CAWRnC,QAXQ,CAAX,CA/E8C,CA4F9C;;;AACA,QAAMoC,eAAe,GAAGrC,OAAO,CAACqC,eAAR,KAA4B,KAA5B,GACpB,QADoB,GAEpB,QAFJ,CA7F8C,CAiG9C;AAEA;AACA;;AAEA,QAAMC,cAAc,GAAG;AACrBxC,UAAM,EAAEA,MADa;AAErB+B,WAAO,EAAEA,OAFY;AAGrBE,QAAI,EAAED,QAHe;AAKrBS,OAAG,EAAE,KALgB;AAMrBC,WAAO,EAAExC,OAAO,CAACwC,OANI;AAOrBC,QAAI,EAAElC,OAPe;AAQrBmC,YAAQ,EAAEL,eARW;AASrBM,YAAQ,EAAE3C,OAAO,CAAC2C,QATG;AAUrBC,aAAS,EAAE5C,OAAO,CAAC4C,SAVE;AAWrBtC,WAAO,EAAEA;AAXY,GAAvB;AAcA,QAAMuC,OAAO,GAAG,IAAIzD,OAAJ,CAAY0B,MAAZ,EAAoBwB,cAApB,CAAhB;AAEAnD,OAAK,CAAC0D,OAAD,CAAL,CACGC,IADH,CACcC,GAAN,6BAAa;AACjB,UAAMxC,OAAO,iBAASwC,GAAG,CAACC,IAAJ,EAAT,CAAb;AACA,UAAMZ,QAAQ,GAAG,EAAjB;AACAA,YAAQ,CAACa,UAAT,GAAsBF,GAAG,CAACG,MAA1B;AACAd,YAAQ,CAAC7B,OAAT,GAAmB,KAAKA,OAAxB,CAJiB,CAMjB;AACA;;AACA6B,YAAQ,CAAC9B,OAAT,GAAmB,EAAnB;;AACA,SAAK,MAAM6C,KAAX,IAAoBJ,GAAG,CAACzC,OAAJ,CAAYiB,OAAZ,EAApB,EAA2C;AACzC,YAAM,CAACE,GAAD,EAAM2B,GAAN,IAAaD,KAAnB;AACAf,cAAQ,CAAC9B,OAAT,CAAiBmB,GAAjB,IAAwB2B,GAAxB;AACD;;AAEDhB,YAAQ,CAACiB,EAAT,GAAcN,GAAG,CAACM,EAAlB;AACAjB,YAAQ,CAACkB,UAAT,GAAsBP,GAAG,CAACO,UAA1B;AAEA9D,gBAAY,CAAC4C,QAAD,CAAZ;;AAEA,QAAIA,QAAQ,CAACa,UAAT,IAAuB,GAA3B,EAAgC;AAC9B,YAAMd,KAAK,GAAG5C,iBAAiB,CAC7B6C,QAAQ,CAACa,UADoB,EAE7Bb,QAAQ,CAAC7B,OAFoB,CAA/B;AAIAN,cAAQ,CAACkC,KAAD,EAAQC,QAAR,CAAR;AACD,KAND,MAMO;AACLnC,cAAQ,CAACsD,SAAD,EAAYnB,QAAZ,CAAR;AACD;AACF,GA5BK,CADR,EA8BGoB,KA9BH,CA8BSC,GAAG,IAAIxD,QAAQ,CAACwD,GAAD,CA9BxB;AA+BD;;AAED3E,IAAI,CAACoB,IAAL,GAAYlB,MAAM,CAAC0E,SAAP,CAAiB7D,KAAjB,CAAZ,C;;;;;;;;;;;ACtKA,IAAI8D,UAAU,GAAG,GAAjB,C,CAAsB;;AACtB,IAAIC,KAAK,GAAGC,KAAK,CAAClE,SAAN,CAAgBiE,KAA5B;;AAEAE,OAAO,CAACvE,iBAAR,GAA4B,UAAS0D,UAAT,EAAqB1C,OAArB,EAA8B;AACxD,MAAIwD,OAAO,GAAG,aAAad,UAAb,GAA0B,GAAxC;;AAEA,MAAI1C,OAAJ,EAAa;AACX,QAAIyD,aAAa,GAAG,OAAOzD,OAAP,IAAkB,QAAlB,GAClBA,OADkB,GACRA,OAAO,CAACe,QAAR,EADZ;AAGAyC,WAAO,IAAI,MAAME,QAAQ,CAACD,aAAa,CAACE,OAAd,CAAsB,KAAtB,EAA6B,GAA7B,CAAD,EAAoCP,UAApC,CAAzB;AACD;;AAED,SAAO,IAAIxD,KAAJ,CAAU4D,OAAV,CAAP;AACD,CAXD;;AAaA,SAASE,QAAT,CAAkBE,GAAlB,EAAuBC,MAAvB,EAA+B;AAC7B,SAAOD,GAAG,CAACC,MAAJ,GAAaA,MAAb,GAAsBD,GAAG,CAACP,KAAJ,CAAU,CAAV,EAAaQ,MAAb,IAAuB,KAA7C,GAAqDD,GAA5D;AACD,C,CAED;;;AACAL,OAAO,CAACtE,YAAR,GAAuB,UAAS4C,QAAT,EAAmB;AACxC;AACA;AACA;AACA,MAAIiC,WAAW,GAAG,CAACjC,QAAQ,CAAC9B,OAAT,CAAiB,cAAjB,KAAoC,GAArC,EAA0CgE,KAA1C,CAAgD,GAAhD,EAAqD,CAArD,CAAlB,CAJwC,CAMxC;;AACA,MAAI,CAAC,kBAAD,EACC,iBADD,EAEC,wBAFD,EAGC,0BAHD,EAIEpD,OAJF,CAIUmD,WAJV,KAI0B,CAJ9B,EAIiC;AAC/B,QAAI;AACFjC,cAAQ,CAAC5B,IAAT,GAAgBC,IAAI,CAAC8D,KAAL,CAAWnC,QAAQ,CAAC7B,OAApB,CAAhB;AACD,KAFD,CAEE,OAAOkD,GAAP,EAAY;AACZrB,cAAQ,CAAC5B,IAAT,GAAgB,IAAhB;AACD;AACF,GAVD,MAUO;AACL4B,YAAQ,CAAC5B,IAAT,GAAgB,IAAhB;AACD;AACF,CApBD;;AAsBA,IAAI1B,IAAI,GAAGgF,OAAO,CAAChF,IAAR,GAAe,EAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,IAAI,CAAC0F,GAAL,GAAW;AAAU;AAAe;AAClC,SAAO1F,IAAI,CAACoB,IAAL,CAAUuE,KAAV,CAAgB,IAAhB,EAAsB,CAAC,KAAD,EAAQC,MAAR,CAAed,KAAK,CAAC1D,IAAN,CAAWyE,SAAX,CAAf,CAAtB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA7F,IAAI,CAAC8F,IAAL,GAAY;AAAU;AAAe;AACnC,SAAO9F,IAAI,CAACoB,IAAL,CAAUuE,KAAV,CAAgB,IAAhB,EAAsB,CAAC,MAAD,EAASC,MAAT,CAAgBd,KAAK,CAAC1D,IAAN,CAAWyE,SAAX,CAAhB,CAAtB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA7F,IAAI,CAAC+F,GAAL,GAAW;AAAU;AAAe;AAClC,SAAO/F,IAAI,CAACoB,IAAL,CAAUuE,KAAV,CAAgB,IAAhB,EAAsB,CAAC,KAAD,EAAQC,MAAR,CAAed,KAAK,CAAC1D,IAAN,CAAWyE,SAAX,CAAf,CAAtB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA7F,IAAI,CAACgG,GAAL,GAAW;AAAU;AAAe;AAClC,SAAOhG,IAAI,CAACoB,IAAL,CAAUuE,KAAV,CAAgB,IAAhB,EAAsB,CAAC,QAAD,EAAWC,MAAX,CAAkBd,KAAK,CAAC1D,IAAN,CAAWyE,SAAX,CAAlB,CAAtB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA7F,IAAI,CAACiG,KAAL,GAAa;AAAU;AAAe;AACpC,SAAOjG,IAAI,CAACoB,IAAL,CAAUuE,KAAV,CAAgB,IAAhB,EAAsB,CAAC,OAAD,EAAUC,MAAV,CAAiBd,KAAK,CAAC1D,IAAN,CAAWyE,SAAX,CAAjB,CAAtB,CAAP;AACD,CAFD,C","file":"/packages/http.js","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { fetch, Request } from 'meteor/fetch';\nimport { URL, URLSearchParams } from 'meteor/url';\nimport { HTTP, makeErrorByStatus, populateData } from './httpcall_common.js';\n\nexport { HTTP };\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * @deprecated\n */\nexport const HTTPInternals = {};\n\n// _call always runs asynchronously; HTTP.call, defined below,\n// wraps _call and runs synchronously when no callback is provided.\nfunction _call (method, url, options, callback) {\n  ////////// Process arguments //////////\n\n  if (!callback && typeof options === 'function') {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (hasOwn.call(options, 'beforeSend')) {\n    throw new Error('Option beforeSend not supported on server.');\n  }\n\n  method = (method || '').toUpperCase();\n\n  if (!/^https?:\\/\\//.test(url)) {\n    throw new Error('url must be absolute and start with http:// or https://');\n  }\n\n  const headers = {};\n  let content = options.content;\n\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n  let paramsForUrl;\n  let paramsForBody;\n\n  if (content || method === 'GET' || method === 'HEAD') {\n    paramsForUrl = options.params;\n  }\n  else {\n    paramsForBody = options.params;\n  }\n\n  const newUrl = URL._constructUrl(url, options.query, paramsForUrl);\n\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0) {\n      throw new Error('auth option should be of the form \"username:password\"');\n    }\n\n    const base64 = Buffer.from(options.auth, 'ascii').toString('base64');\n    headers['Authorization'] = `Basic ${base64}`;\n  }\n\n  if (paramsForBody) {\n    const data = new URLSearchParams();\n    Object.entries(paramsForBody).forEach(([key, value]) => {\n      data.append(key, value);\n    });\n    content = data;\n    headers['Content-Type'] = 'application/x-www-form-urlencoded';\n  }\n\n  if (options.headers) {\n    Object.keys(options.headers).forEach(function (key) {\n      headers[key] = options.headers[key];\n    });\n  }\n\n  let caching;\n  if (options.caching) {\n    // TODO implement fetch-specific options\n  }\n\n  let corsMode;\n  if (options.mode) {\n    // TODO implement fetch-specific options\n  }\n\n  let credentials;\n\n  // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n  callback = (function (cb) {\n    let called = false;\n    return function (error, response) {\n      if (!called) {\n        called = true;\n        if (error && response) {\n          error.response = response;\n        }\n        cb(error, response);\n      }\n    }\n  })(callback);\n\n  // is false if false, otherwise always true\n  const followRedirects = options.followRedirects === false\n    ? 'manual'\n    : 'follow';\n\n  ////////// Kickoff! //////////\n\n  // Allow users to override any request option with the npmRequestOptions\n  // option.\n\n  const requestOptions = {\n    method: method,\n    caching: caching,\n    mode: corsMode,\n\n    jar: false,\n    timeout: options.timeout,\n    body: content,\n    redirect: followRedirects,\n    referrer: options.referrer,\n    integrity: options.integrity,\n    headers: headers\n  };\n\n  const request = new Request(newUrl, requestOptions);\n\n  fetch(request)\n    .then(async res => {\n      const content = await res.text();\n      const response = {};\n      response.statusCode = res.status;\n      response.content = '' + content;\n\n      // fetch headers don't allow simple read using bracket notation\n      // so we iterate their entries and assign them to a new Object\n      response.headers = {};\n      for (const entry of res.headers.entries()) {\n        const [key, val] = entry;\n        response.headers[key] = val;\n      }\n\n      response.ok = res.ok;\n      response.redirected = res.redirected;\n\n      populateData(response);\n\n      if (response.statusCode >= 400) {\n        const error = makeErrorByStatus(\n          response.statusCode,\n          response.content\n        );\n        callback(error, response);\n      } else {\n        callback(undefined, response);\n      }\n    })\n    .catch(err => callback(err));\n}\n\nHTTP.call = Meteor.wrapAsync(_call);\n","var MAX_LENGTH = 500; // if you change this, also change the appropriate test\nvar slice = Array.prototype.slice;\n\nexports.makeErrorByStatus = function(statusCode, content) {\n  var message = \"failed [\" + statusCode + \"]\";\n\n  if (content) {\n    var stringContent = typeof content == \"string\" ?\n      content : content.toString();\n\n    message += ' ' + truncate(stringContent.replace(/\\n/g, ' '), MAX_LENGTH);\n  }\n\n  return new Error(message);\n};\n\nfunction truncate(str, length) {\n  return str.length > length ? str.slice(0, length) + '...' : str;\n}\n\n// Fill in `response.data` if the content-type is JSON.\nexports.populateData = function(response) {\n  // Read Content-Type header, up to a ';' if there is one.\n  // A typical header might be \"application/json; charset=utf-8\"\n  // or just \"application/json\".\n  var contentType = (response.headers['content-type'] || ';').split(';')[0];\n\n  // Only try to parse data as JSON if server sets correct content type.\n  if (['application/json',\n       'text/javascript',\n       'application/javascript',\n       'application/x-javascript',\n      ].indexOf(contentType) >= 0) {\n    try {\n      response.data = JSON.parse(response.content);\n    } catch (err) {\n      response.data = null;\n    }\n  } else {\n    response.data = null;\n  }\n};\n\nvar HTTP = exports.HTTP = {};\n\n/**\n * @summary Send an HTTP `GET` request. Equivalent to calling [`HTTP.call`](#http_call) with \"GET\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\nHTTP.get = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"GET\"].concat(slice.call(arguments)));\n};\n\n/**\n * @summary Send an HTTP `POST` request. Equivalent to calling [`HTTP.call`](#http_call) with \"POST\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\nHTTP.post = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"POST\"].concat(slice.call(arguments)));\n};\n\n/**\n * @summary Send an HTTP `PUT` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PUT\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\nHTTP.put = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"PUT\"].concat(slice.call(arguments)));\n};\n\n/**\n * @summary Send an HTTP `DELETE` request. Equivalent to calling [`HTTP.call`](#http_call) with \"DELETE\" as the first argument. (Named `del` to avoid conflict with the Javascript keyword `delete`)\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\nHTTP.del = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"DELETE\"].concat(slice.call(arguments)));\n};\n\n/**\n * @summary Send an HTTP `PATCH` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PATCH\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n * @deprecated\n */\nHTTP.patch = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"PATCH\"].concat(slice.call(arguments)));\n};\n"]}}]