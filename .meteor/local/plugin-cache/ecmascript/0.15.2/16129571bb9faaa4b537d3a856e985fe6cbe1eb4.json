{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\Haseeb\\Desktop\\firstReact\\myapp\\packages\\cfs:gridfs\\gridfs.server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/cfs:gridfs/gridfs.server.js","filename":"C:\\Users\\Haseeb\\Desktop\\firstReact\\myapp\\packages\\cfs:gridfs\\gridfs.server.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\Haseeb\\Desktop\\firstReact\\myapp","root":"C:\\Users\\Haseeb\\Desktop\\firstReact\\myapp","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.14.0","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\Haseeb\\Desktop\\firstReact\\myapp\\packages\\cfs:gridfs\\gridfs.server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cfs:gridfs/gridfs.server.js"}},"code":"var path = Npm.require('path');\n\nvar mongodb = Npm.require('mongodb');\n\nvar ObjectID = Npm.require('mongodb').ObjectID;\n\nvar Grid = Npm.require('gridfs-stream'); //var Grid = Npm.require('gridfs-locking-stream');\n\n\nvar chunkSize = 1024 * 1024 * 2; // 256k is default GridFS chunk size, but performs terribly for largish files\n\n/**\n * @public\n * @constructor\n * @param {String} name - The store name\n * @param {Object} options\n * @param {Function} [options.beforeSave] - Function to run before saving a file from the server. The context of the function will be the `FS.File` instance we're saving. The function may alter its properties.\n * @param {Number} [options.maxTries=5] - Max times to attempt saving a file\n * @returns {FS.StorageAdapter} An instance of FS.StorageAdapter.\n *\n * Creates a GridFS store instance on the server. Inherits from FS.StorageAdapter\n * type.\n */\n\nFS.Store.GridFS = function (name, options) {\n  var self = this;\n  options = options || {};\n  var gridfsName = name;\n  var mongoOptions = options.mongoOptions || {};\n  if (!(self instanceof FS.Store.GridFS)) throw new Error('FS.Store.GridFS missing keyword \"new\"');\n\n  if (!options.mongoUrl) {\n    options.mongoUrl = process.env.MONGO_URL; // When using a Meteor MongoDB instance, preface name with \"cfs_gridfs.\"\n\n    gridfsName = \"cfs_gridfs.\" + name;\n  }\n\n  if (!options.mongoOptions) {\n    options.mongoOptions = {\n      db: {\n        native_parser: true\n      },\n      server: {\n        auto_reconnect: true\n      }\n    };\n  }\n\n  if (options.chunkSize) {\n    chunkSize = options.chunkSize;\n  }\n\n  return new FS.StorageAdapter(name, options, {\n    typeName: 'storage.gridfs',\n    fileKey: function (fileObj) {\n      // We should not have to mount the file here - We assume its taken\n      // care of - Otherwise we create new files instead of overwriting\n      var key = {\n        _id: null,\n        filename: null\n      }; // If we're passed a fileObj, we retrieve the _id and filename from it.\n\n      if (fileObj) {\n        var info = fileObj._getInfo(name, {\n          updateFileRecordFirst: false\n        });\n\n        key._id = info.key || null;\n        key.filename = info.name || fileObj.name({\n          updateFileRecordFirst: false\n        }) || fileObj.collectionName + '-' + fileObj._id;\n      } // If key._id is null at this point, createWriteStream will let GridFS generate a new ID\n\n\n      return key;\n    },\n    createReadStream: function (fileKey, options) {\n      options = options || {}; // Init GridFS\n\n      var gfs = new Grid(self.db, mongodb); // Set the default streamning settings\n\n      var settings = {\n        _id: new ObjectID(fileKey._id),\n        root: gridfsName\n      }; // Check if this should be a partial read\n\n      if (typeof options.start !== 'undefined' && typeof options.end !== 'undefined') {\n        // Add partial info\n        settings.range = {\n          startPos: options.start,\n          endPos: options.end\n        };\n      }\n\n      FS.debug && console.log('GRIDFS', settings);\n      return gfs.createReadStream(settings);\n    },\n    createWriteStream: function (fileKey, options) {\n      options = options || {}; // Init GridFS\n\n      var gfs = new Grid(self.db, mongodb);\n      var opts = {\n        filename: fileKey.filename,\n        mode: 'w',\n        root: gridfsName,\n        chunk_size: options.chunk_size || chunkSize,\n        // We allow aliases, metadata and contentType to be passed in via\n        // options\n        aliases: options.aliases || [],\n        metadata: options.metadata || null,\n        content_type: options.contentType || 'application/octet-stream'\n      };\n\n      if (fileKey._id) {\n        opts._id = new ObjectID(fileKey._id);\n      }\n\n      var writeStream = gfs.createWriteStream(opts);\n      writeStream.on('close', function (file) {\n        if (!file) {\n          // gridfs-stream will emit \"close\" without passing a file\n          // if there is an error. We can simply exit here because\n          // the \"error\" listener will also be called in this case.\n          return;\n        }\n\n        if (FS.debug) console.log('SA GridFS - DONE!'); // Emit end and return the fileKey, size, and updated date\n\n        writeStream.emit('stored', {\n          // Set the generated _id so that we know it for future reads and writes.\n          // We store the _id as a string and only convert to ObjectID right before\n          // reading, writing, or deleting. If we store the ObjectID itself,\n          // Meteor (EJSON?) seems to convert it to a LocalCollection.ObjectID,\n          // which GFS doesn't understand.\n          fileKey: file._id.toString(),\n          size: file.length,\n          storedAt: file.uploadDate || new Date()\n        });\n      });\n      writeStream.on('error', function (error) {\n        console.log('SA GridFS - ERROR!', error);\n      });\n      return writeStream;\n    },\n    remove: function (fileKey, callback) {\n      // Init GridFS\n      var gfs = new Grid(self.db, mongodb);\n\n      try {\n        gfs.remove({\n          _id: new ObjectID(fileKey._id),\n          root: gridfsName\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n    },\n    // Not implemented\n    watch: function () {\n      throw new Error(\"GridFS storage adapter does not support the sync option\");\n    },\n    init: function (callback) {\n      mongodb.MongoClient.connect(options.mongoUrl, mongoOptions, function (err, db) {\n        if (err) {\n          return callback(err);\n        }\n\n        self.db = db;\n        callback(null);\n      });\n    }\n  });\n};","map":{"version":3,"sources":["packages/cfs:gridfs/gridfs.server.js"],"names":["path","Npm","require","mongodb","ObjectID","Grid","chunkSize","FS","Store","GridFS","name","options","self","gridfsName","mongoOptions","Error","mongoUrl","process","env","MONGO_URL","db","native_parser","server","auto_reconnect","StorageAdapter","typeName","fileKey","fileObj","key","_id","filename","info","_getInfo","updateFileRecordFirst","collectionName","createReadStream","gfs","settings","root","start","end","range","startPos","endPos","debug","console","log","createWriteStream","opts","mode","chunk_size","aliases","metadata","content_type","contentType","writeStream","on","file","emit","toString","size","length","storedAt","uploadDate","Date","error","remove","callback","err","watch","init","MongoClient","connect"],"mappings":"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","sourcesContent":["var path = Npm.require('path');\nvar mongodb = Npm.require('mongodb');\nvar ObjectID = Npm.require('mongodb').ObjectID;\nvar Grid = Npm.require('gridfs-stream');\n//var Grid = Npm.require('gridfs-locking-stream');\n\nvar chunkSize = 1024*1024*2; // 256k is default GridFS chunk size, but performs terribly for largish files\n\n/**\n * @public\n * @constructor\n * @param {String} name - The store name\n * @param {Object} options\n * @param {Function} [options.beforeSave] - Function to run before saving a file from the server. The context of the function will be the `FS.File` instance we're saving. The function may alter its properties.\n * @param {Number} [options.maxTries=5] - Max times to attempt saving a file\n * @returns {FS.StorageAdapter} An instance of FS.StorageAdapter.\n *\n * Creates a GridFS store instance on the server. Inherits from FS.StorageAdapter\n * type.\n */\n\nFS.Store.GridFS = function(name, options) {\n  var self = this;\n  options = options || {};\n\n  var gridfsName = name;\n  var mongoOptions = options.mongoOptions || {};\n\n  if (!(self instanceof FS.Store.GridFS))\n    throw new Error('FS.Store.GridFS missing keyword \"new\"');\n\n  if (!options.mongoUrl) {\n    options.mongoUrl = process.env.MONGO_URL;\n    // When using a Meteor MongoDB instance, preface name with \"cfs_gridfs.\"\n    gridfsName = \"cfs_gridfs.\" + name;\n  }\n\n  if (!options.mongoOptions) {\n    options.mongoOptions = { db: { native_parser: true }, server: { auto_reconnect: true }};\n  }\n\n  if (options.chunkSize) {\n    chunkSize = options.chunkSize;\n  }\n\n  return new FS.StorageAdapter(name, options, {\n\n    typeName: 'storage.gridfs',\n    fileKey: function(fileObj) {\n      // We should not have to mount the file here - We assume its taken\n      // care of - Otherwise we create new files instead of overwriting\n      var key = {\n        _id: null,\n        filename: null\n      };\n\n      // If we're passed a fileObj, we retrieve the _id and filename from it.\n      if (fileObj) {\n        var info = fileObj._getInfo(name, {updateFileRecordFirst: false});\n        key._id = info.key || null;\n        key.filename = info.name || fileObj.name({updateFileRecordFirst: false}) || (fileObj.collectionName + '-' + fileObj._id);\n      }\n\n      // If key._id is null at this point, createWriteStream will let GridFS generate a new ID\n      return key;\n    },\n    createReadStream: function(fileKey, options) {\n      options = options || {};\n\n      // Init GridFS\n      var gfs = new Grid(self.db, mongodb);\n\n      // Set the default streamning settings\n      var settings = {\n        _id: new ObjectID(fileKey._id),\n        root: gridfsName\n      };\n\n      // Check if this should be a partial read\n      if (typeof options.start !== 'undefined' && typeof options.end !== 'undefined' ) {\n        // Add partial info\n        settings.range = {\n          startPos: options.start,\n          endPos: options.end\n        };\n      }\n\n      FS.debug && console.log('GRIDFS', settings);\n\n      return gfs.createReadStream(settings);\n\n    },\n    createWriteStream: function(fileKey, options) {\n      options = options || {};\n\n      // Init GridFS\n      var gfs = new Grid(self.db, mongodb);\n\n      var opts = {\n        filename: fileKey.filename,\n        mode: 'w',\n        root: gridfsName,\n        chunk_size: options.chunk_size || chunkSize,\n        // We allow aliases, metadata and contentType to be passed in via\n        // options\n        aliases: options.aliases || [],\n        metadata: options.metadata || null,\n        content_type: options.contentType || 'application/octet-stream'\n      };\n\n      if (fileKey._id) {\n        opts._id = new ObjectID(fileKey._id);\n      }\n\n      var writeStream = gfs.createWriteStream(opts);\n\n      writeStream.on('close', function(file) {\n        if (!file) {\n          // gridfs-stream will emit \"close\" without passing a file\n          // if there is an error. We can simply exit here because\n          // the \"error\" listener will also be called in this case.\n          return;\n        }\n\n        if (FS.debug) console.log('SA GridFS - DONE!');\n\n        // Emit end and return the fileKey, size, and updated date\n        writeStream.emit('stored', {\n          // Set the generated _id so that we know it for future reads and writes.\n          // We store the _id as a string and only convert to ObjectID right before\n          // reading, writing, or deleting. If we store the ObjectID itself,\n          // Meteor (EJSON?) seems to convert it to a LocalCollection.ObjectID,\n          // which GFS doesn't understand.\n          fileKey: file._id.toString(),\n          size: file.length,\n          storedAt: file.uploadDate || new Date()\n        });\n      });\n\n      writeStream.on('error', function(error) {\n        console.log('SA GridFS - ERROR!', error);\n      });\n\n      return writeStream;\n\n    },\n    remove: function(fileKey, callback) {\n      // Init GridFS\n      var gfs = new Grid(self.db, mongodb);\n\n      try {\n        gfs.remove({ _id: new ObjectID(fileKey._id), root: gridfsName }, callback);\n      } catch(err) {\n        callback(err);\n      }\n    },\n\n    // Not implemented\n    watch: function() {\n      throw new Error(\"GridFS storage adapter does not support the sync option\");\n    },\n\n    init: function(callback) {\n      mongodb.MongoClient.connect(options.mongoUrl, mongoOptions, function (err, db) {\n        if (err) { return callback(err); }\n        self.db = db;\n        callback(null);\n      });\n    }\n  });\n};\n"]},"sourceType":"module","hash":"16129571bb9faaa4b537d3a856e985fe6cbe1eb4"}
